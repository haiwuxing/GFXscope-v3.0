package com.gold.wurf;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.text.DecimalFormat;
import java.util.ArrayList;

import com.gold.wurf.FragmentClientActivity.ConnectTask;
import com.gold.wurf.TCP_Client.PreferencesManager;
import com.gold.wurf.TCP_Client.TcpClient;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.graphics.Typeface;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.preference.PreferenceManager;
import android.support.v4.app.Fragment;
import android.text.method.ScrollingMovementMethod;
import android.util.Base64;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

public class FragmentMain extends Fragment/* implements android.view.View.OnClickListener*/ {
	// Логгирование внутри IDE
	private static final String LOG_TAG = "FlankLOGS";

    private ListView mList;
    private ArrayList<String> arrayList;
    private ClientListAdapter mAdapter;
    private TcpClient mTcpClient;

	// Кнопка "Отправить"
	Button SendBtn;
	// TextView с результатами (вычисленный вурф и первичное объяснение)
	TextView etMessage;
	// Настройки, которые хранятся в файле. "Хранить ТОП-10" фрагмента настроек
	SharedPreferences sPref;

	// Шрифтовые переменные
	/*public static final String MYFONT = "fonts/Monotype_corsiva.ttf";
	private static Typeface myfont = null;*/

	// Создаём объект, который содержит метод setBackgroundImage замены фоновой картинки 
	// в зависимости от ориентации экрана
    DynamicOrientationDetection DOD = new DynamicOrientationDetection();

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
	    super.onConfigurationChanged(newConfig);
	    // Ставим фоновую картинку в зависимости от ориентации экрана
	    // getClass().getSimpleName() - это "FragmentMain", имя класса
	    DOD.setBackgroundImage(this.getResources().getConfiguration().orientation, getClass().getSimpleName(), getView());
    }

	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
	    // Отображаем содержимое фрагмента fragment_main
	    setRetainInstance(true);
	    // Получаем вид фрагмента (по умолчанию с вертикальной фоновой картинкой снежинки)
	    View v = inflater.inflate(R.layout.fragment_main, null);
	    // Вызываем метод, который проверяет ориентацию экрана и ставит соответствующую фоновую картинку со снежинкой
	    DOD.setBackgroundImage(this.getResources().getConfiguration().orientation, getClass().getSimpleName(), v);
		// Это нужно, чтобы отработал метод onPrepareOptionsMenu. Также для этого вызываем getActivity().invalidateOptionsMenu() в OnViewCreated
		// Обусловлено это тем, что мы хотим менять доступность пунктов меню (см. onPrepareOptionsMenu) из фрагмента, а не из MainActivity, где всё было бы проще
		setHasOptionsMenu(true);
	    // Возвращаем вид с нужной фоновой картинкой
	    return v;
	}

    // Добавил этот метод, т.к. необходимо работать с меню MainActivity из этого фрагмента
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        getActivity().invalidateOptionsMenu();

        arrayList = new ArrayList<String>();

        final EditText etMessage = (EditText) getView().findViewById(R.id.etMessage);
        Button send = (Button) getView().findViewById(R.id.SendBtn);

        //relate the listView from java to the one created in xml
        mList = (ListView) getView().findViewById(R.id.list);
        mAdapter = new ClientListAdapter(getActivity(), arrayList);
        mList.setAdapter(mAdapter);
//arrayList.add("5");
        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
Log.d(LOG_TAG, "Была нажата кнопка Отправить");
                String message = etMessage.getText().toString();
Log.d(LOG_TAG, "Отправляемый текст: "+message);
                //add the text in the arrayList
                arrayList.add("Client: " + message);

                //sends the message to the server
                if (mTcpClient != null) {
                    mTcpClient.sendMessage(message);
                }
Log.d(LOG_TAG, "Текст отправлен");
                //refresh the list
                mAdapter.notifyDataSetChanged();
                etMessage.setText("");
Log.d(LOG_TAG, "Конец отправки");
            }
        });

    } 

    // Метод конвертирует массив byte в массив Integer
    public int[] bytearray2intarray(byte[] barray)
    {
        int[] iarray = new int[barray.length];
        int i = 0;
        for (byte b : barray)
            iarray[i++] = b & 0xff;
        return iarray;
    }

    @Override
	public void onPause() {
        super.onPause();

        if (mTcpClient != null) {
            // disconnect
            mTcpClient.stopClient();
            mTcpClient = null;
        }

    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        if (mTcpClient != null) {
            // if the client is connected, enable the connect button and disable the disconnect one
            menu.getItem(1).setEnabled(true);
            menu.getItem(0).setEnabled(false);
        } else {
            // if the client is disconnected, enable the disconnect button and disable the connect one
            menu.getItem(1).setEnabled(false);
            menu.getItem(0).setEnabled(true);
        }
        super.onPrepareOptionsMenu(menu);
    }

	// Обработчик пунктов меню (НЕ ActionBar)
	// return true означает, что клик будет обработан данным фрагментом, return false - что клик будет обработан MainActivity
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle item selection
        switch (item.getItemId()) {
			case 1:
				// ПОДКЛЮЧИТЬСЯ
//	            String username = PreferencesManager.getInstance().getUserName();
	            // check if we have the username saved in the preferences, if not, notify the user to write one down
//	            if (username != null) {
	                // connect to the server
	                new ConnectTask().execute("");
//	            } else {
//	                Toast.makeText(getActivity(), "Please got to preferences and set a username first!", Toast.LENGTH_LONG).show();
//	            }
Log.d(LOG_TAG, "ПОДКЛЮЧИТЬСЯ");
				return true;
			case 2:
				// ОТКЛЮЧИТЬСЯ
	            if (mTcpClient == null) {
	                return true;
	            }
	            // disconnect
	            mTcpClient.stopClient();
	            mTcpClient = null;
	            // clear the data set
	            arrayList.clear();
	            // notify the adapter that the data set has changed.
	            mAdapter.notifyDataSetChanged();
Log.d(LOG_TAG, "ОТКЛЮЧИТЬСЯ");
				return true;
			case 3:
				// НАСТРОЙКИ
	            //startActivity(new Intent(this, PreferencesActivity.class));
				return false;
			case 4:
				// ВЫХОД. Завершаем работу приложения
				//getActivity().finish();
				return false;
			default: return super.onOptionsItemSelected(item);
        }

    }

    public class ConnectTask extends AsyncTask<String, String, TcpClient> {

        @Override
        protected TcpClient doInBackground(String... message) {
Log.d(LOG_TAG, "doInBackground 1");
            //we create a TCPClient object and
            mTcpClient = new TcpClient(new TcpClient.OnMessageReceived() {
                @Override
                //here the messageReceived method is implemented
                public void messageReceived(String message) {
Log.d(LOG_TAG, "doInBackground 2");
					publishProgress("Server: " + message);
Log.d(LOG_TAG, "doInBackground 3");
                }
            });
            mTcpClient.run();
Log.d(LOG_TAG, "doInBackground 4");
            return null;
        }

        @Override
        protected void onProgressUpdate(String... values) {
            super.onProgressUpdate(values);

            //in the arrayList we add the messaged received from server
Log.d(LOG_TAG, "onProgressUpdate message received: " + values[0]);
            arrayList.add(values[0]);
            // notify the adapter that the data set has changed. This means that new message received
            // from server was added to the list
            mAdapter.notifyDataSetChanged();
        }
    }

	// Обработчик нажатия кнопки "Отправить"
	/*public void onClick(View v)
	{Log.d(LOG_TAG, "Была нажата кнопка Отправить+");
		// Вурф будет вида 1.618
		DecimalFormat WurfFormat = new DecimalFormat("#.###");
		String Explanation = getString(R.string.YourWurf) + WurfFormat.format(WurfValue) + " ";
		Log.d(LOG_TAG, "Отработала функция расчёта вурфа с параметрами "+(int)R1+" "+(int)R2+" "+(int)R3+" "+(int)R4);

	    // Получаем статус галки "Хранить ТОП-10" фрагмента настроек (true/false)
	    Boolean pref_SaveWurfs = true;
	    sPref = PreferenceManager.getDefaultSharedPreferences(getActivity());
	    if(sPref.contains("pref_SaveWurfs"))
	    {
		    pref_SaveWurfs = sPref.getBoolean("pref_SaveWurfs", true);
	    }
		// Пишем или НЕ пишем рассчитанный вурф в файл. Зависит от статуса галки "Хранить ТОП-10" в фрагменте настроек
		// Если галка УСТАНОВЛЕНА
		if(pref_SaveWurfs)
		{
		}
	}*/

	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);

/*		// Находим кнопку "Рассчитать вурф" и текстовое поле с пояснением результата
		SendBtn = (Button) getView().findViewById(R.id.SendBtn);
//		SendBtn.setOnClickListener(this);
		etMessage = (EditText) getView().findViewById(R.id.etMessage);
		//etMessage.setMovementMethod(new ScrollingMovementMethod());
		//etMessage.setScrollbarFadingEnabled(false);
		// Устанавливаем им шрифт Monotype corsiva
		if (myfont == null)
		{
			Typeface Monotype_corsiva = Typeface.createFromAsset(getActivity().getAssets(), MYFONT);
			etMessage.setTypeface(Monotype_corsiva);
			SendBtn.setTypeface(Monotype_corsiva);
		}*/
		Log.d(LOG_TAG, "Визуальные элементы найдены");
	}

}
